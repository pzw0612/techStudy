线程状态图
1、新建状态
用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。
注意：不能对已经启动的线程再次调用start()方法，否则会出现java.lang.IllegalThreadStateException异常。
2、就绪状态
处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。
提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。
3、运行状态
处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。
当发生如下情况是，线程会从运行状态变为阻塞状态：
①、线程调用sleep方法主动放弃所占用的系统资源
②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有
④、线程在等待某个通知（notify）
⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。
当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。
4、阻塞状态
处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 
在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。有三种方法可以暂停Threads执行：
5、死亡状态
当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。


一、如何结束一个线程
Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法。

1、正常执行完run方法，然后结束掉

2、控制循环条件和判断条件的标识符来结束掉线程


 3、使用interrupt结束一个线程。

诚然，使用第2中方法的标识符来结束一个线程，是一个不错的方法，但是如果，该线程是处于sleep、wait、join的状态的时候，while循环就不会执行，那么我们的标识符就无用武之地了，当然也不能再通过它来结束处于这3种状态的线程了。

可以使用interrupt这个巧妙的方式结束掉这个线程。

我们看看sleep、wait、join方法的声明：


public final void wait() throws InterruptedException  

public static native void sleep(long millis) throws InterruptedException  

public final void join() throws InterruptedException  

可以看到，这三者有一个共同点，都抛出了一个InterruptedException的异常。

在什么时候会产生这样一个异常呢？

每个Thread都有一个中断状状态，默认为false。可以通过Thread对象的isInterrupted()方法来判断该线程的中断状态。可以通过Thread对象的interrupt()方法将中断状态设置为true。

当一个线程处于sleep、wait、join这三种状态之一的时候，如果此时他的中断状态为true，那么它就会抛出一个InterruptedException的异常，并将中断状态重新设置为false。



可以看到，首先执行第一次while循环，在第一次循环中，睡眠2秒，然后将中断状态设置为true。当进入到第二次循环的时候，中断状态就是第一次设置的true，当它再次进入sleep的时候，马上就抛出了InterruptedException异常，然后被我们捕获了。然后中断状态又被重新自动设置为false了（从最后一条输出可以看出来）。

   
